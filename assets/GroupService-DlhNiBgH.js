const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/main-CIF9t6XU.js","assets/main-D0prcIsd.css"])))=>i.map(i=>d[i]);
import{f as R,i as w,h,Y as f,ax as G,e as y,q as E,P as D,g as v,Z as j,k as C,ay as x,_ as S,az as q,l as W}from"./main-CIF9t6XU.js";const I=R;if(!I)throw new Error("Firestore must be initialized");class B{constructor(){this.db=I}async createGroupWallet(r,e){const t={platformId:`group_${r}`,groupId:r,ownerId:e,name:"Group Wallet",logo:"/images/BankrollLogoTransparent.png",cashBalance:0,bonusBalances:[],totalBonusBalance:0,lastUpdated:new Date,status:"active",connected:!0,memberBalances:{},expenses:[]},o=w(this.db,"groups",r);return await h(o,{wallet:t}),await this.addGroupWalletToUser(e,t),t}async addGroupWalletToUser(r,e){const t=w(this.db,"users",r),a=(await f(t)).data();if(a!=null&&a.wallet){const s=a.wallet;s.subWallets[e.platformId]=e,await h(t,{"wallet.subWallets":s.subWallets})}}async getGroupWallet(r){const e=w(this.db,"groups",r),o=(await f(e)).data();return(o==null?void 0:o.wallet)||null}async addFunds(r,e,t){await G(this.db,async o=>{const a=w(this.db,"groups",r),n=(await o.get(a)).data();if(!(n!=null&&n.wallet))throw new Error("Group wallet not found");const i=n.wallet;i.cashBalance+=e,i.lastUpdated=new Date,i.memberBalances[t]=(i.memberBalances[t]||0)+e,o.update(a,{wallet:i});const c={id:crypto.randomUUID(),walletId:r,platformId:i.platformId,type:"deposit",amount:e,timestamp:new Date,status:"completed",metadata:{userId:t,description:"Group wallet deposit"}};o.set(w(this.db,"wallet_transactions",c.id),c)})}async addExpense(r,e,t,o,a){await G(this.db,async s=>{const n=w(this.db,"groups",r),c=(await s.get(n)).data();if(!(c!=null&&c.wallet))throw new Error("Group wallet not found");const l=c.wallet,d={id:crypto.randomUUID(),description:e,amount:t,paidBy:o,splitBetween:a,timestamp:new Date,status:"completed"};l.expenses.push(d);const m=t/a.length;a.forEach(u=>{u!==o&&(l.memberBalances[u]=(l.memberBalances[u]||0)-m)}),l.memberBalances[o]=(l.memberBalances[o]||0)+t,s.update(n,{wallet:l});const p={id:crypto.randomUUID(),walletId:r,platformId:l.platformId,type:"group_expense",amount:t,timestamp:new Date,status:"completed",metadata:{expenseId:d.id,paidBy:o,splitBetween:a,description:e}};s.set(w(this.db,"wallet_transactions",p.id),p)})}async getMemberBalance(r,e){const t=await this.getGroupWallet(r);if(!t)throw new Error("Group wallet not found");return t.memberBalances[e]||0}async getExpenses(r){const e=await this.getGroupWallet(r);if(!e)throw new Error("Group wallet not found");return e.expenses}}const U=new B,g=R;class b{constructor(){if(this.groupsCollection="groups",this.usersCollection="users",this.baseUrl="https://bankroll.live",b.instance)return b.instance;b.instance=this}generateGroupUrl(r){return`${this.baseUrl}/groups/${r}`}createInitialWallet(r,e){return{platformId:`group_${r}`,groupId:r,ownerId:e,name:"Group Wallet",logo:"/images/BankrollLogoTransparent.png",cashBalance:0,bonusBalances:[],totalBonusBalance:0,lastUpdated:new Date,status:"active",connected:!0,memberBalances:{},expenses:[]}}async getUserGroups(r){try{if(!r)throw new Error("User ID is required");const e=y(g,this.groupsCollection),t=E(e,D("memberIds","array-contains",r)),o=await v(t),a=[];for(const s of o.docs){const n=s.data(),i=await this.getUserData(n.ownerId),c=(n.memberIds||[]).map(async u=>{try{return await this.getUserData(u)}catch(M){return console.error(`Error fetching member data for ${u}:`,M),null}}),d=(await Promise.all(c)).filter(u=>u!==null),m=Array.from(new Map(d.map(u=>[u.uid,u])).values());let p=n.wallet;p||(p=this.createInitialWallet(s.id,n.ownerId),await h(s.ref,{wallet:p})),a.push({id:s.id,name:n.name||"",description:n.description||"",emoji:n.emoji||"ðŸ‘¥",ownerId:n.ownerId,owner:i,members:m,memberIds:n.memberIds||[],pendingMembers:n.pendingMembers||[],dateCreated:n.dateCreated||new Date().toISOString(),isHidden:n.isHidden||!1,visibility:n.visibility||"private",inviteLink:this.generateGroupUrl(s.id),status:n.status||"active",wallet:p,type:n.type||"default",leagueInfo:n.leagueInfo||null})}return a}catch(e){throw console.error("Error fetching user groups:",e),e}}async getUserData(r){try{const e=w(g,this.usersCollection,r),t=await f(e);return t.exists()?{uid:r,...t.data()}:null}catch(e){throw console.error("Error fetching user data:",e),e}}async getGroup(r){try{if(!r)throw new Error("Group ID is required");const e=w(g,this.groupsCollection,r),t=await f(e);if(t.exists()){const o=t.data(),a=await this.getUserData(o.ownerId),s=(o.memberIds||[]).map(async d=>{try{return await this.getUserData(d)}catch(m){return console.error(`Error fetching member data for ${d}:`,m),null}}),i=(await Promise.all(s)).filter(d=>d!==null),c=Array.from(new Map(i.map(d=>[d.uid,d])).values());let l=o.wallet;return l||(l=this.createInitialWallet(r,o.ownerId),await h(e,{wallet:l})),{id:t.id,name:o.name||"",description:o.description||"",emoji:o.emoji||"ðŸ‘¥",ownerId:o.ownerId,owner:a,members:c,memberIds:o.memberIds||[],pendingMembers:o.pendingMembers||[],dateCreated:o.dateCreated||new Date().toISOString(),isHidden:o.isHidden||!1,visibility:o.visibility||"private",inviteLink:this.generateGroupUrl(t.id),status:o.status||"active",wallet:l,type:o.type||"default",leagueInfo:o.leagueInfo||null}}else throw new Error("Group not found")}catch(e){throw console.error("Error fetching group:",e),e}}async createGroup(r,e){try{if(!e||!e.id&&!e.uid)throw new Error("Creator information is required");if(!r)throw new Error("Group data is required");if(!r.name)throw new Error("Group name is required");if(!e.id&&!e.uid)throw new Error("Creator must have an id or uid property");const t=e.id||e.uid,o=j(),a=y(g,this.groupsCollection),s=await this.getUserData(t),n=this.createInitialWallet(o,t),i={id:o,name:r.name,emoji:r.emoji||"ðŸ‘¥",description:r.description||"",ownerId:t,owner:s,members:[s],memberIds:[t],pendingMembers:[],dateCreated:new Date().toISOString(),isHidden:!1,visibility:r.visibility||"private",inviteLink:this.generateGroupUrl(o),status:"active",wallet:n,type:r.type||"default",leagueInfo:r.leagueInfo||null},c=await C(a,i);return await h(c,{id:c.id}),await U.createGroupWallet(c.id,t),{...i,id:c.id}}catch(t){throw console.error("Error creating group:",t),t}}async inviteUsers(r,e){try{if(!r||!e||!e.length)throw new Error("Group ID and at least one email are required");const t=w(g,this.groupsCollection,r),o=await f(t);if(!o.exists())throw new Error("Group not found");const a=o.data(),s=[],n=new Set([...(a.members||[]).map(c=>c.email||""),...(a.pendingMembers||[]).map(c=>c.identifier||"")].filter(Boolean)),i=e.filter(c=>!n.has(c));return i.length===0?{success:!0,message:"All emails are already invited or members",invitedCount:0,skippedCount:e.length}:(i.forEach(c=>{s.push({identifier:c,type:"email",status:"pending",invitedAt:new Date().toISOString()})}),await h(t,{pendingMembers:[...a.pendingMembers||[],...s]}),{success:!0,message:`Successfully added ${i.length} invites`,invitedCount:i.length,skippedCount:e.length-i.length})}catch(t){throw console.error("Error inviting users:",t),t}}async removePendingInvite(r,e){try{if(!r||!e)throw new Error("Group ID and email are required");const t=w(g,this.groupsCollection,r),o=await f(t);if(!o.exists())throw new Error("Group not found");const n=(o.data().pendingMembers||[]).filter(i=>i.identifier!==e);return await h(t,{pendingMembers:n}),await this.getGroup(r)}catch(t){throw console.error("Error removing pending invite:",t),t}}async requestToJoinGroup(r,e){var t,o;try{if(!r||!e)throw new Error("Group ID and User ID are required");const a=w(g,this.groupsCollection,r),s=await f(a);if(!s.exists())throw new Error("Group not found");const n=s.data();if((t=n.memberIds)!=null&&t.includes(e))throw new Error("User is already a member of this group");const i=await this.getUserData(e);if(!i)throw new Error("User not found");if((o=n.joinRequests)==null?void 0:o.find(d=>d.userId===e))throw new Error("User already has a pending join request");const l={userId:e,user:i,requestedAt:new Date().toISOString(),status:"pending"};await h(a,{joinRequests:x(l)});try{const{notificationsService:d}=await S(async()=>{const{notificationsService:m}=await import("./main-CIF9t6XU.js").then(p=>p.bw);return{notificationsService:m}},__vite__mapDeps([0,1]));await d.sendNotification(n.ownerId,{type:"GROUP_JOIN_REQUEST",title:"New Join Request",body:`${i.displayName||i.email} wants to join ${n.name}`,data:{groupId:r,groupName:n.name,userId:e,userName:i.displayName||i.email,action:"group_join_request"}},["push","email"])}catch(d){console.error("Error sending notification:",d)}}catch(a){throw console.error("Error requesting to join group:",a),a}}async approveJoinRequest(r,e,t){var o,a;try{const s=w(g,this.groupsCollection,r),n=await f(s);if(!n.exists())throw new Error("Group not found");const i=n.data();if(i.ownerId!==t&&!((o=i.adminIds)!=null&&o.includes(t)))throw new Error("Only group owner or admins can approve join requests");if(!((a=i.joinRequests)==null?void 0:a.find(u=>u.userId===e&&u.status==="pending")))throw new Error("Join request not found");const l=await this.getUserData(e);if(!l)throw new Error("User not found");const d=i.joinRequests.map(u=>u.userId===e?{...u,status:"approved",approvedBy:t,approvedAt:new Date().toISOString()}:u),m=[...i.members||[],l],p=[...i.memberIds||[],e];return await h(s,{members:m,memberIds:p,joinRequests:d}),await U.initializeMemberBalance(r,e),await this.getGroup(r)}catch(s){throw console.error("Error approving join request:",s),s}}async rejectJoinRequest(r,e,t){var o,a;try{const s=w(g,this.groupsCollection,r),n=await f(s);if(!n.exists())throw new Error("Group not found");const i=n.data();if(i.ownerId!==t&&!((o=i.adminIds)!=null&&o.includes(t)))throw new Error("Only group owner or admins can reject join requests");const c=((a=i.joinRequests)==null?void 0:a.map(l=>l.userId===e?{...l,status:"rejected",rejectedBy:t,rejectedAt:new Date().toISOString()}:l))||[];await h(s,{joinRequests:c})}catch(s){throw console.error("Error rejecting join request:",s),s}}async joinGroup(r,e){var t,o;try{if(!r||!e)throw new Error("Group ID and User ID are required");const a=w(g,this.groupsCollection,r),s=await f(a);if(!s.exists())throw new Error("Group not found");const n=s.data();if(n.memberIds.includes(e))throw new Error("User is already a member of this group");const i=await this.getUserData(e);if(!i)throw new Error("User not found");const c=(t=n.pendingMembers)==null?void 0:t.find(u=>u.identifier===i.email),l=n.inviteCode&&n.inviteCodeCreatedAt;if(!c&&!l&&n.visibility!=="public")throw await this.requestToJoinGroup(r,e),new Error("Join request sent. Waiting for admin approval.");const d=((o=n.pendingMembers)==null?void 0:o.filter(u=>u.identifier!==i.email))||[],m=[...n.members,i],p=[...n.memberIds,e];if(await h(a,{members:m,memberIds:p,pendingMembers:d}),n.wallet){const u={...n.wallet,memberBalances:{...n.wallet.memberBalances,[e]:0}};await h(a,{wallet:u})}return await this.getGroup(r)}catch(a){throw console.error("Error joining group:",a),a}}async updateGroup(r,e){try{if(!r)throw new Error("Group ID is required");const t=w(g,this.groupsCollection,r);if(!(await f(t)).exists())throw new Error("Group not found");return await h(t,e),await this.getGroup(r)}catch(t){throw console.error("Error updating group:",t),t}}async deleteGroup(r){try{if(!r)throw new Error("Group ID is required");const t=q().currentUser;if(!t)throw new Error("User must be authenticated to delete a group");const o=w(g,this.groupsCollection,r),a=await f(o);if(!a.exists())throw new Error("Group not found");if(a.data().ownerId!==t.uid)throw new Error("Only the group owner can delete the group");return await W(o),!0}catch(e){throw console.error("Error deleting group:",e),e}}async checkGroupExists(r,e){try{if(!q().currentUser)throw new Error("User must be authenticated to check group existence");if(!r||!e)throw new Error("League ID and platform are required");const a=y(g,this.groupsCollection),s=E(a,D("leagueInfo.leagueId","==",r.toString()),D("leagueInfo.platform","==",e));return!(await v(s)).empty}catch(t){throw console.error("Error checking group existence:",t),t}}async getPublicGroups(){try{const r=y(g,this.groupsCollection),e=E(r,D("visibility","==","public")),t=await v(e),o=[];for(const a of t.docs){const s=a.data(),n=await this.getUserData(s.ownerId),i=(s.memberIds||[]).map(async p=>{try{return await this.getUserData(p)}catch(u){return console.error(`Error fetching member data for ${p}:`,u),null}}),l=(await Promise.all(i)).filter(p=>p!==null),d=Array.from(new Map(l.map(p=>[p.uid,p])).values());let m=s.wallet;m||(m=this.createInitialWallet(a.id,s.ownerId)),o.push({id:a.id,...s,owner:n,members:d,memberIds:d.map(p=>p.uid),wallet:m,pendingMembers:s.pendingMembers||[],joinRequests:s.joinRequests||[]})}return o}catch(r){throw console.error("Error fetching public groups:",r),r}}}const O=new b;export{O as g};
