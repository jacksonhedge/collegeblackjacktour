const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/main-Bt21LLck.js","assets/main-D0prcIsd.css"])))=>i.map(i=>d[i]);
var S=Object.defineProperty;var W=(b,t,e)=>t in b?S(b,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):b[t]=e;var y=(b,t,e)=>W(b,typeof t!="symbol"?t+"":t,e);import{f as j,i as w,h,Y as f,ax as R,e as E,q as G,P as v,g as q,Z as B,k as P,ay as O,_,az as I,l as k}from"./main-Bt21LLck.js";const C=j;if(!C)throw new Error("Firestore must be initialized");class A{constructor(){y(this,"db");this.db=C}async createGroupWallet(t,e){const r={platformId:`group_${t}`,groupId:t,ownerId:e,name:"Group Wallet",logo:"/images/BankrollLogoTransparent.png",cashBalance:0,bonusBalances:[],totalBonusBalance:0,lastUpdated:new Date,status:"active",connected:!0,memberBalances:{},expenses:[]},o=w(this.db,"groups",t);return await h(o,{wallet:r}),await this.addGroupWalletToUser(e,r),r}async addGroupWalletToUser(t,e){const r=w(this.db,"users",t),a=(await f(r)).data();if(a!=null&&a.wallet){const s=a.wallet;s.subWallets[e.platformId]=e,await h(r,{"wallet.subWallets":s.subWallets})}}async getGroupWallet(t){const e=w(this.db,"groups",t),o=(await f(e)).data();return(o==null?void 0:o.wallet)||null}async addFunds(t,e,r){await R(this.db,async o=>{const a=w(this.db,"groups",t),n=(await o.get(a)).data();if(!(n!=null&&n.wallet))throw new Error("Group wallet not found");const i=n.wallet;i.cashBalance+=e,i.lastUpdated=new Date,i.memberBalances[r]=(i.memberBalances[r]||0)+e,o.update(a,{wallet:i});const c={id:crypto.randomUUID(),walletId:t,platformId:i.platformId,type:"deposit",amount:e,timestamp:new Date,status:"completed",metadata:{userId:r,description:"Group wallet deposit"}};o.set(w(this.db,"wallet_transactions",c.id),c)})}async addExpense(t,e,r,o,a){await R(this.db,async s=>{const n=w(this.db,"groups",t),c=(await s.get(n)).data();if(!(c!=null&&c.wallet))throw new Error("Group wallet not found");const l=c.wallet,d={id:crypto.randomUUID(),description:e,amount:r,paidBy:o,splitBetween:a,timestamp:new Date,status:"completed"};l.expenses.push(d);const m=r/a.length;a.forEach(u=>{u!==o&&(l.memberBalances[u]=(l.memberBalances[u]||0)-m)}),l.memberBalances[o]=(l.memberBalances[o]||0)+r,s.update(n,{wallet:l});const p={id:crypto.randomUUID(),walletId:t,platformId:l.platformId,type:"group_expense",amount:r,timestamp:new Date,status:"completed",metadata:{expenseId:d.id,paidBy:o,splitBetween:a,description:e}};s.set(w(this.db,"wallet_transactions",p.id),p)})}async getMemberBalance(t,e){const r=await this.getGroupWallet(t);if(!r)throw new Error("Group wallet not found");return r.memberBalances[e]||0}async getExpenses(t){const e=await this.getGroupWallet(t);if(!e)throw new Error("Group wallet not found");return e.expenses}}const M=new A,g=j,D=class D{constructor(){y(this,"groupsCollection","groups");y(this,"usersCollection","users");y(this,"baseUrl","https://bankroll.live");if(D.instance)return D.instance;D.instance=this}generateGroupUrl(t){return`${this.baseUrl}/groups/${t}`}createInitialWallet(t,e){return{platformId:`group_${t}`,groupId:t,ownerId:e,name:"Group Wallet",logo:"/images/BankrollLogoTransparent.png",cashBalance:0,bonusBalances:[],totalBonusBalance:0,lastUpdated:new Date,status:"active",connected:!0,memberBalances:{},expenses:[]}}async getUserGroups(t){try{if(!t)throw new Error("User ID is required");const e=E(g,this.groupsCollection),r=G(e,v("memberIds","array-contains",t)),o=await q(r),a=[];for(const s of o.docs){const n=s.data(),i=await this.getUserData(n.ownerId),c=(n.memberIds||[]).map(async u=>{try{return await this.getUserData(u)}catch(x){return console.error(`Error fetching member data for ${u}:`,x),null}}),d=(await Promise.all(c)).filter(u=>u!==null),m=Array.from(new Map(d.map(u=>[u.uid,u])).values());let p=n.wallet;p||(p=this.createInitialWallet(s.id,n.ownerId),await h(s.ref,{wallet:p})),a.push({id:s.id,name:n.name||"",description:n.description||"",emoji:n.emoji||"ðŸ‘¥",ownerId:n.ownerId,owner:i,members:m,memberIds:n.memberIds||[],pendingMembers:n.pendingMembers||[],dateCreated:n.dateCreated||new Date().toISOString(),isHidden:n.isHidden||!1,visibility:n.visibility||"private",inviteLink:this.generateGroupUrl(s.id),status:n.status||"active",wallet:p,type:n.type||"default",leagueInfo:n.leagueInfo||null})}return a}catch(e){throw console.error("Error fetching user groups:",e),e}}async getUserData(t){try{const e=w(g,this.usersCollection,t),r=await f(e);return r.exists()?{uid:t,...r.data()}:null}catch(e){throw console.error("Error fetching user data:",e),e}}async getGroup(t){try{if(!t)throw new Error("Group ID is required");const e=w(g,this.groupsCollection,t),r=await f(e);if(r.exists()){const o=r.data(),a=await this.getUserData(o.ownerId),s=(o.memberIds||[]).map(async d=>{try{return await this.getUserData(d)}catch(m){return console.error(`Error fetching member data for ${d}:`,m),null}}),i=(await Promise.all(s)).filter(d=>d!==null),c=Array.from(new Map(i.map(d=>[d.uid,d])).values());let l=o.wallet;return l||(l=this.createInitialWallet(t,o.ownerId),await h(e,{wallet:l})),{id:r.id,name:o.name||"",description:o.description||"",emoji:o.emoji||"ðŸ‘¥",ownerId:o.ownerId,owner:a,members:c,memberIds:o.memberIds||[],pendingMembers:o.pendingMembers||[],dateCreated:o.dateCreated||new Date().toISOString(),isHidden:o.isHidden||!1,visibility:o.visibility||"private",inviteLink:this.generateGroupUrl(r.id),status:o.status||"active",wallet:l,type:o.type||"default",leagueInfo:o.leagueInfo||null}}else throw new Error("Group not found")}catch(e){throw console.error("Error fetching group:",e),e}}async createGroup(t,e){try{if(!e||!e.id&&!e.uid)throw new Error("Creator information is required");if(!t)throw new Error("Group data is required");if(!t.name)throw new Error("Group name is required");if(!e.id&&!e.uid)throw new Error("Creator must have an id or uid property");const r=e.id||e.uid,o=B(),a=E(g,this.groupsCollection),s=await this.getUserData(r),n=this.createInitialWallet(o,r),i={id:o,name:t.name,emoji:t.emoji||"ðŸ‘¥",description:t.description||"",ownerId:r,owner:s,members:[s],memberIds:[r],pendingMembers:[],dateCreated:new Date().toISOString(),isHidden:!1,visibility:t.visibility||"private",inviteLink:this.generateGroupUrl(o),status:"active",wallet:n,type:t.type||"default",leagueInfo:t.leagueInfo||null},c=await P(a,i);return await h(c,{id:c.id}),await M.createGroupWallet(c.id,r),{...i,id:c.id}}catch(r){throw console.error("Error creating group:",r),r}}async inviteUsers(t,e){try{if(!t||!e||!e.length)throw new Error("Group ID and at least one email are required");const r=w(g,this.groupsCollection,t),o=await f(r);if(!o.exists())throw new Error("Group not found");const a=o.data(),s=[],n=new Set([...(a.members||[]).map(c=>c.email||""),...(a.pendingMembers||[]).map(c=>c.identifier||"")].filter(Boolean)),i=e.filter(c=>!n.has(c));return i.length===0?{success:!0,message:"All emails are already invited or members",invitedCount:0,skippedCount:e.length}:(i.forEach(c=>{s.push({identifier:c,type:"email",status:"pending",invitedAt:new Date().toISOString()})}),await h(r,{pendingMembers:[...a.pendingMembers||[],...s]}),{success:!0,message:`Successfully added ${i.length} invites`,invitedCount:i.length,skippedCount:e.length-i.length})}catch(r){throw console.error("Error inviting users:",r),r}}async removePendingInvite(t,e){try{if(!t||!e)throw new Error("Group ID and email are required");const r=w(g,this.groupsCollection,t),o=await f(r);if(!o.exists())throw new Error("Group not found");const n=(o.data().pendingMembers||[]).filter(i=>i.identifier!==e);return await h(r,{pendingMembers:n}),await this.getGroup(t)}catch(r){throw console.error("Error removing pending invite:",r),r}}async requestToJoinGroup(t,e){var r,o;try{if(!t||!e)throw new Error("Group ID and User ID are required");const a=w(g,this.groupsCollection,t),s=await f(a);if(!s.exists())throw new Error("Group not found");const n=s.data();if((r=n.memberIds)!=null&&r.includes(e))throw new Error("User is already a member of this group");const i=await this.getUserData(e);if(!i)throw new Error("User not found");if((o=n.joinRequests)==null?void 0:o.find(d=>d.userId===e))throw new Error("User already has a pending join request");const l={userId:e,user:i,requestedAt:new Date().toISOString(),status:"pending"};await h(a,{joinRequests:O(l)});try{const{notificationsService:d}=await _(async()=>{const{notificationsService:m}=await import("./main-Bt21LLck.js").then(p=>p.bw);return{notificationsService:m}},__vite__mapDeps([0,1]));await d.sendNotification(n.ownerId,{type:"GROUP_JOIN_REQUEST",title:"New Join Request",body:`${i.displayName||i.email} wants to join ${n.name}`,data:{groupId:t,groupName:n.name,userId:e,userName:i.displayName||i.email,action:"group_join_request"}},["push","email"])}catch(d){console.error("Error sending notification:",d)}}catch(a){throw console.error("Error requesting to join group:",a),a}}async approveJoinRequest(t,e,r){var o,a;try{const s=w(g,this.groupsCollection,t),n=await f(s);if(!n.exists())throw new Error("Group not found");const i=n.data();if(i.ownerId!==r&&!((o=i.adminIds)!=null&&o.includes(r)))throw new Error("Only group owner or admins can approve join requests");if(!((a=i.joinRequests)==null?void 0:a.find(u=>u.userId===e&&u.status==="pending")))throw new Error("Join request not found");const l=await this.getUserData(e);if(!l)throw new Error("User not found");const d=i.joinRequests.map(u=>u.userId===e?{...u,status:"approved",approvedBy:r,approvedAt:new Date().toISOString()}:u),m=[...i.members||[],l],p=[...i.memberIds||[],e];return await h(s,{members:m,memberIds:p,joinRequests:d}),await M.initializeMemberBalance(t,e),await this.getGroup(t)}catch(s){throw console.error("Error approving join request:",s),s}}async rejectJoinRequest(t,e,r){var o,a;try{const s=w(g,this.groupsCollection,t),n=await f(s);if(!n.exists())throw new Error("Group not found");const i=n.data();if(i.ownerId!==r&&!((o=i.adminIds)!=null&&o.includes(r)))throw new Error("Only group owner or admins can reject join requests");const c=((a=i.joinRequests)==null?void 0:a.map(l=>l.userId===e?{...l,status:"rejected",rejectedBy:r,rejectedAt:new Date().toISOString()}:l))||[];await h(s,{joinRequests:c})}catch(s){throw console.error("Error rejecting join request:",s),s}}async joinGroup(t,e){var r,o;try{if(!t||!e)throw new Error("Group ID and User ID are required");const a=w(g,this.groupsCollection,t),s=await f(a);if(!s.exists())throw new Error("Group not found");const n=s.data();if(n.memberIds.includes(e))throw new Error("User is already a member of this group");const i=await this.getUserData(e);if(!i)throw new Error("User not found");const c=(r=n.pendingMembers)==null?void 0:r.find(u=>u.identifier===i.email),l=n.inviteCode&&n.inviteCodeCreatedAt;if(!c&&!l&&n.visibility!=="public")throw await this.requestToJoinGroup(t,e),new Error("Join request sent. Waiting for admin approval.");const d=((o=n.pendingMembers)==null?void 0:o.filter(u=>u.identifier!==i.email))||[],m=[...n.members,i],p=[...n.memberIds,e];if(await h(a,{members:m,memberIds:p,pendingMembers:d}),n.wallet){const u={...n.wallet,memberBalances:{...n.wallet.memberBalances,[e]:0}};await h(a,{wallet:u})}return await this.getGroup(t)}catch(a){throw console.error("Error joining group:",a),a}}async updateGroup(t,e){try{if(!t)throw new Error("Group ID is required");const r=w(g,this.groupsCollection,t);if(!(await f(r)).exists())throw new Error("Group not found");return await h(r,e),await this.getGroup(t)}catch(r){throw console.error("Error updating group:",r),r}}async deleteGroup(t){try{if(!t)throw new Error("Group ID is required");const r=I().currentUser;if(!r)throw new Error("User must be authenticated to delete a group");const o=w(g,this.groupsCollection,t),a=await f(o);if(!a.exists())throw new Error("Group not found");if(a.data().ownerId!==r.uid)throw new Error("Only the group owner can delete the group");return await k(o),!0}catch(e){throw console.error("Error deleting group:",e),e}}async checkGroupExists(t,e){try{if(!I().currentUser)throw new Error("User must be authenticated to check group existence");if(!t||!e)throw new Error("League ID and platform are required");const a=E(g,this.groupsCollection),s=G(a,v("leagueInfo.leagueId","==",t.toString()),v("leagueInfo.platform","==",e));return!(await q(s)).empty}catch(r){throw console.error("Error checking group existence:",r),r}}async getPublicGroups(){try{const t=E(g,this.groupsCollection),e=G(t,v("visibility","==","public")),r=await q(e),o=[];for(const a of r.docs){const s=a.data(),n=await this.getUserData(s.ownerId),i=(s.memberIds||[]).map(async p=>{try{return await this.getUserData(p)}catch(u){return console.error(`Error fetching member data for ${p}:`,u),null}}),l=(await Promise.all(i)).filter(p=>p!==null),d=Array.from(new Map(l.map(p=>[p.uid,p])).values());let m=s.wallet;m||(m=this.createInitialWallet(a.id,s.ownerId)),o.push({id:a.id,...s,owner:n,members:d,memberIds:d.map(p=>p.uid),wallet:m,pendingMembers:s.pendingMembers||[],joinRequests:s.joinRequests||[]})}return o}catch(t){throw console.error("Error fetching public groups:",t),t}}};y(D,"instance");let U=D;const T=new U;export{T as g};
